<html>
<head>
</head>
<body>

<style>

#KeyboardRoot {

  /* position: absolute;
  top: 10px;
  left: 100px; */

  width: 350px;
  height: 250px;

  border: 0px solid red;
  
  z-index: 1;
}

</style>

<div id="KeyboardRoot"><!-- This div's content will be managed by React. --></div>

<script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin ></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin ></script>

<!-- Import maps polyfill -->
<script type="importmap" >
  { "imports": { "three": "/wp-content/plugins/three.js/build/three.module.js" } }
</script>

<!-- Remove this when import maps will be widely supported -->
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js" ></script>




<script type="module">

  import * as THREE from 'three';

  // import { GUI } from '/wp-content/plugins/three.js/examples/jsm/libs/lil-gui.module.min.js';
  import { OrbitControls } from '/wp-content/plugins/three.js/examples/jsm/controls/OrbitControls.js';
  import { GLTFLoader } from '/wp-content/plugins/three.js/examples/jsm/loaders/GLTFLoader.js';
  // import { OBJLoader } from '/wp-content/plugins/three.js/examples/jsm/loaders/OBJLoader.js';

  let scene, renderer, camera;
  let model, skeleton, clock;

  let canvasW = 350;
  let canvasH = 250;

  init();

  function init() {

    const container = document.getElementById( 'KeyboardRoot' );
    clock = new THREE.Clock();

    scene = new THREE.Scene();
    // scene.background = new THREE.Color( 0xa0a0a0 );
    // scene.fog = new THREE.Fog( 0xa0a0a0, 10, 50 );

    const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
    hemiLight.position.set( 20, 20, 0 );
    scene.add( hemiLight );

    const dirLight = new THREE.DirectionalLight( 0xffffff );
    dirLight.position.set( 3, 10, 10 );
    dirLight.castShadow = true;
    dirLight.shadow.camera.top = 2;
    dirLight.shadow.camera.bottom = - 2;
    dirLight.shadow.camera.left = - 2;
    dirLight.shadow.camera.right = 2;
    dirLight.shadow.camera.near = 0.1;
    dirLight.shadow.camera.far = 40;
    scene.add( dirLight );

    /* ground */
    // const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 100, 100 ), new THREE.MeshPhongMaterial( { color: 0x333333, depthWrite: false } ) );
    // mesh.rotation.x = - Math.PI / 2;
    // mesh.receiveShadow = true;
    // scene.add( mesh );

    const loader = new GLTFLoader();
    let modelPath
    modelPath = '/wp-content/themes/sydney/obj/new-systems.gltf'
    loader.load(modelPath, function ( gltf ) {

      model = gltf.scene;
      // model.translateZ(-10);
      scene.add( model );

      // model.traverse( function ( object ) {
      //   if ( object.isMesh ) object.castShadow = true;
      // } );

      // skeleton = new THREE.SkeletonHelper( model );
      // skeleton.visible = false;
      // scene.add( skeleton );

      animate();
    } );


    renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
    renderer.setPixelRatio( window.devicePixelRatio );
    // renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setSize( canvasW, canvasH );
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.shadowMap.enabled = true;
    container.appendChild( renderer.domElement );

    /*
     * fov, aspect, near, far
    **/
    camera = new THREE.PerspectiveCamera( 66, 1, 1, 1000 );
    camera.position.set( 100, 0, 50 );
    // let rnd_1 = Math.random()*8-4 // between -4 and 4
    // camera.position.set( -12, 0, rnd_1 );
    camera.aspect = canvasW/canvasH;
    camera.updateProjectionMatrix();


    // const axesHelper = new THREE.AxesHelper( 5 );
    // scene.add( axesHelper );     
    
    const controls = new OrbitControls( camera, renderer.domElement );
    controls.enablePan = false;
    controls.enableZoom = false;
    controls.target.set( 0, 1, 0 );
    controls.update();

    window.addEventListener( 'resize', onWindowResize );
  }

  function onWindowResize() {
    // camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    // renderer.setSize( window.innerWidth, window.innerHeight );
  }

  var matrix = new THREE.Matrix4(); // Pre-allocate empty matrix for performance. Don't want to make one of these every frame.
  var period = 60; // rotation time in seconds

  function animate() {
    model.rotateY(-0.01);

    // matrix.makeRotationX(clock.getDelta() * 2 * Math.PI / period);
    // camera.position.applyMatrix4(matrix);
    camera.lookAt(0, 0, 0);

    requestAnimationFrame( animate );
    renderer.render( scene, camera );
  }

</script>

</body></html>
