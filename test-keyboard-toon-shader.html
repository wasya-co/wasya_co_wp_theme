<html>
<head>
</head>
<body>

<style>

#KeyboardRoot {

  /* position: absolute;
  top: 10px;
  left: 100px; */

  width: 500px;
  height: 500px;

  border: 0px solid red;
  
  z-index: 1;
}

</style>

<div id="KeyboardRoot"><!-- This div's content will be managed by React. --></div>

<script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin ></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin ></script>

<!-- Import maps polyfill -->
<script type="importmap" >
  { "imports": { "three": "/wp-content/plugins/three.js/build/three.module.js" } }
</script>

<!-- Remove this when import maps will be widely supported -->
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js" ></script>




<script type="module">

  import * as THREE from 'three';

  // import { GUI } from '/wp-content/plugins/three.js/examples/jsm/libs/lil-gui.module.min.js';
  import { OrbitControls } from '/wp-content/plugins/three.js/examples/jsm/controls/OrbitControls.js';
  import { GLTFLoader } from '/wp-content/plugins/three.js/examples/jsm/loaders/GLTFLoader.js';
  import { OBJLoader } from '/wp-content/plugins/three.js/examples/jsm/loaders/OBJLoader.js';
  import * as GeoUtils from '/wp-content/plugins/three.js/examples/jsm/utils/BufferGeometryUtils.js';

  let scene, renderer, camera;
  let model, skeleton, clock;

  let canvasW = 1000;
  let canvasH = 500;



/**
 * Usage: logg(someObject, 'label')
 *
 * This development-grade logger can be used instead of console.log() with some advantages:
 * * It encourages consistent labeling of logs. By labeling each log line, you can have dozens of log lines
 * written per action, and still know which log line comes from where.
 * The recommended label is the component name, or function name.
 * * If the label is present, the logged object is placed in the window, allowing you to inspect it in the console. The
 * label becomes the name of the object (stripped to [0-9a-zA-Z\-_] chars). If you're logging a function, you can execute it.
 * If you log more than one thing, they can interact, allowing you to validate control flow.
 * * the logger can be turned off by making this function simply return.
 */
const logg = (a, b="", c=null) => {
  c = "string" === typeof c ? c : b.replace(/\W/g, "");
  if (c.length > 0) {
    window[c] = a;
  }

  console.log(`+++ ${b}:`, a); // eslint-disable-line no-console
};


  init();

  function init() {

    const container = document.getElementById( 'KeyboardRoot' );
    clock = new THREE.Clock();

    scene = new THREE.Scene();
    // scene.background = new THREE.Color('black');
    
    // scene.background = new THREE.Color( 0xa0a0a0 );
    // scene.fog = new THREE.Fog( 0xa0a0a0, 10, 50 );

    // const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
    // hemiLight.position.set( 20, 20, 0 );
    // scene.add( hemiLight );

    const dirLight = new THREE.DirectionalLight( 0xffffff );
    dirLight.position.set( 3, 10, 10 );
    dirLight.castShadow = true;
    dirLight.shadow.camera.top = 2;
    dirLight.shadow.camera.bottom = - 2;
    dirLight.shadow.camera.left = - 2;
    dirLight.shadow.camera.right = 2;
    dirLight.shadow.camera.near = 0.1;
    dirLight.shadow.camera.far = 40;
    scene.add( dirLight );

    let loader = new GLTFLoader()
    loader = new OBJLoader()
    let modelPath = '/wp-content/themes/sydney/obj/new-systems.obj'
    loader.load(modelPath, function ( model ) {

      // scene.add( model )
      // model.translateZ(-10);

      const textureLoader = new THREE.TextureLoader();
      const fiveTone = textureLoader.load( '/wp-content/themes/sydney/obj/fiveTone.jpeg' );
      fiveTone.minFilter = THREE.NearestFilter;
      fiveTone.magFilter = THREE.NearestFilter;

      let material, simpleMaterial
      simpleMaterial = new THREE.MeshBasicMaterial({ color: 0x999933 })
      // material = new THREE.MeshToonMaterial( {
      //   color: 0xff6666, 
      //   // castShadow: true,
      //   // receiveShadow: true,
      //   gradientMap: fiveTone,
      // } );
      // material = new THREE.MeshBasicMaterial({ color: 0x003300, outline: true })
      // material = new THREE.ShadowMaterial({ opacity: 1, color: 0xffffff, wireframe: true });

      function vertexShader() {
        // with lights
        return `
        #if NUM_DIR_LIGHTS > 0
            struct DirectionalLight {
                vec3 direction;
                vec3 color;
                int shadow;
                float shadowBias;
                float shadowRadius;
                vec2 shadowMapSize;
            };
            uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
        #endif
        varying vec3 color;
        varying vec3 vUv;   
        void main() {
          vUv = position; 

          float r = directionalLights[0].color.r;
          color = vec3(r,1.0,0.0);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position , 1.0);
        }`;
          
        // default, works
        return `
          varying vec3 vUv; 

          void main() {
            vUv = position; 
            vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
            gl_Position = projectionMatrix * modelViewPosition; 
          }
        `
      }
      function fragmentShader() {
        return `
            uniform vec3 colorA; 
            uniform vec3 colorB; 
            varying vec3 vUv;

            void main() {
              gl_FragColor = vec4(mix(colorA, colorB, vUv.z), 1.0);
              // gl_FragColor = vec4(colorA, 1.0);
            }
        `
      }
      material = new THREE.ShaderMaterial( {
        uniforms: {
          ...THREE.UniformsLib[ "lights" ],
          colorA: {type: 'vec3', value: new THREE.Color(0xff0000)},
          colorB: {type: 'vec3', value: new THREE.Color(0x0000FF)},
        },
        vertexShader: vertexShader(),
        fragmentShader: fragmentShader(),
        lights: true,
        // vertexShader: document.getElementById( 'vertexShader' ).textContent,
        // fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
      } );

      logg(model, 'ze model')

      var geometry = new THREE.BufferGeometry()

      var g0 = model.children[0].geometry
      var g1 = model.children[1].geometry

      geometry = GeoUtils.mergeBufferGeometries([ g0, g1 ])
      
      const outlineMat = new THREE.MeshLambertMaterial({
        color:'black',
        side: THREE.BackSide,
      })
      outlineMat.onBeforeCompile = (shader) => {
        const token = `#include <begin_vertex>`
        const customTransform = `
          vec3 transformed = position + objectNormal*0.3;
        `
        shader.vertexShader =  shader.vertexShader.replace(token,customTransform)
      }

      const mesh_1 = new THREE.Mesh( geometry, outlineMat )
      scene.add( mesh_1 )
      const mesh_2 = new THREE.Mesh( geometry, simpleMaterial )
      scene.add( mesh_2 )

      // model.traverse( function ( object ) {
      //   if ( object.isMesh ) {
          
      //     object.material = material
      //     // object.material.castShadow = true;
      //     // object.material.receiveShadow = true;
      //   }
      // } );

      // const mesh = new THREE.Mesh( geometry, material );
      animate();
    } );


    renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
    renderer.setPixelRatio( window.devicePixelRatio );
    // renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setSize( canvasW, canvasH );
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.shadowMap.enabled = true;
    container.appendChild( renderer.domElement );

    /*
     * fov, aspect, near, far
    **/
    camera = new THREE.PerspectiveCamera( 66, 1, 1, 1000 );
    camera.position.set( 100, 0, 50 );
    // let rnd_1 = Math.random()*8-4 // between -4 and 4
    // camera.position.set( -12, 0, rnd_1 );
    camera.aspect = canvasW/canvasH;
    camera.updateProjectionMatrix();


    // const axesHelper = new THREE.AxesHelper( 5 );
    // scene.add( axesHelper );     
    
    const controls = new OrbitControls( camera, renderer.domElement );
    controls.enablePan = false;
    controls.enableZoom = false;
    controls.target.set( 0, 1, 0 );
    controls.update();

    window.addEventListener( 'resize', onWindowResize );
  }

  function onWindowResize() {
    // camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    // renderer.setSize( window.innerWidth, window.innerHeight );
  }

  var matrix = new THREE.Matrix4(); // Pre-allocate empty matrix for performance. Don't want to make one of these every frame.
  var period = 60; // rotation time in seconds

  function animate() {
    // model.rotateY(-0.01);

    // matrix.makeRotationX(clock.getDelta() * 2 * Math.PI / period);
    // camera.position.applyMatrix4(matrix);
    camera.lookAt(0, 0, 0);


    requestAnimationFrame( animate );
    renderer.render( scene, camera );
  }

</script>

</body></html>
