
<style>

#root {
  position: absolute;
  top: 170px;
  left: 0;
  width: 100%;
  border: 1px solid red;
  /* background: rgba(0,0,255,.5); */
  /* background: #999; */
  z-index: 1;
}

</style>

<div id="root"><!-- This div's content will be managed by React. --></div>

<script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>

<!-- Import maps polyfill -->
<script type="importmap">
  { "imports": { "three": "/wp-content/threejs/build/three.module.js" } }
</script>
<!-- Remove this when import maps will be widely supported -->
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

<script type="module">

  import * as THREE from 'three';

  import { GUI } from '/wp-content/threejs/examples/jsm/libs/lil-gui.module.min.js';
  import { OrbitControls } from '/wp-content/threejs/examples/jsm/controls/OrbitControls.js';
  import { GLTFLoader } from '/wp-content/threejs/examples/jsm/loaders/GLTFLoader.js';
  import { OBJLoader } from '/wp-content/threejs/examples/jsm/loaders/OBJLoader.js';

  let scene, renderer, camera;
  let model, skeleton, clock;

  let canvasW = window.innerWidth;
  let canvasH = 600;

  init();

  function init() {

    // const container = document.getElementsByClassName( 'entry-content' )[0];
    const container = document.getElementById( 'root' );
    clock = new THREE.Clock();

    scene = new THREE.Scene();
    // scene.background = new THREE.Color( 0xa0a0a0 );
    // scene.fog = new THREE.Fog( 0xa0a0a0, 10, 50 );

    const hemiLight = new THREE.HemisphereLight( 0xffffff, 0x444444 );
    hemiLight.position.set( 0, 20, 0 );
    scene.add( hemiLight );

    const dirLight = new THREE.DirectionalLight( 0xffffff );
    dirLight.position.set( 3, 10, 10 );
    dirLight.castShadow = true;
    dirLight.shadow.camera.top = 2;
    dirLight.shadow.camera.bottom = - 2;
    dirLight.shadow.camera.left = - 2;
    dirLight.shadow.camera.right = 2;
    dirLight.shadow.camera.near = 0.1;
    dirLight.shadow.camera.far = 40;
    scene.add( dirLight );

    /* ground */
    // const mesh = new THREE.Mesh( new THREE.PlaneGeometry( 100, 100 ), new THREE.MeshPhongMaterial( { color: 0x333333, depthWrite: false } ) );
    // mesh.rotation.x = - Math.PI / 2;
    // mesh.receiveShadow = true;
    // scene.add( mesh );

    let modelPath

    const loader = new GLTFLoader();
    modelPath = '/wp-content/uploads/assets/obj/BlocksHumanoid.gltf'
    loader.load(modelPath, function ( gltf ) {

      model = gltf.scene;
      // model.translateZ(-10);
      scene.add( model );

      // model.traverse( function ( object ) {
      //   if ( object.isMesh ) object.castShadow = true;
      // } );

      // skeleton = new THREE.SkeletonHelper( model );
      // skeleton.visible = false;
      // scene.add( skeleton );

      animate();
    } );


    renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
    renderer.setPixelRatio( window.devicePixelRatio );
    // renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.setSize( canvasW, canvasH );
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.shadowMap.enabled = true;
    container.appendChild( renderer.domElement );

    /*
     * fov, aspect, near, far
    **/
    camera = new THREE.PerspectiveCamera( 66.6, 1, 1, 100 );
    // camera.position.set( -1, 2, 3 );
    let rnd_1 = Math.random()*8-4 // between -4 and 4
    camera.position.set( -12, 0, rnd_1 );
    camera.aspect = canvasW/canvasH;
    camera.updateProjectionMatrix();


    // const axesHelper = new THREE.AxesHelper( 5 );
    // scene.add( axesHelper );     
    
    const controls = new OrbitControls( camera, renderer.domElement );
    controls.enablePan = false;
    controls.enableZoom = false;
    controls.target.set( 0, 1, 0 );
    controls.update();

    window.addEventListener( 'resize', onWindowResize );
  }

  function activateAction( action ) {
    const clip = action.getClip();
    const settings = baseActions[ clip.name ] || additiveActions[ clip.name ];
    setWeight( action, settings.weight );
    action.play();
  }

  // This function is needed, since animationAction.crossFadeTo() disables its start action and sets
  // the start action's timeScale to ((start animation's duration) / (end animation's duration))
  function setWeight( action, weight ) {
    action.enabled = true;
    action.setEffectiveTimeScale( 1 );
    action.setEffectiveWeight( weight );
  }

  function onWindowResize() {
    // camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    // renderer.setSize( window.innerWidth, window.innerHeight );
  }

  var matrix = new THREE.Matrix4(); // Pre-allocate empty matrix for performance. Don't want to make one of these every frame.
  var period = 60; // rotation time in seconds

  function animate() {
    // model.rotateZ(0.0005);
    model.rotateZ(0.1/200);
    model.rotateY(0.025/200);

    matrix.makeRotationX(clock.getDelta() * 2 * Math.PI / period);
    camera.position.applyMatrix4(matrix);
    camera.lookAt(0, 0, 0);

    requestAnimationFrame( animate );
    renderer.render( scene, camera );
  }

</script>

